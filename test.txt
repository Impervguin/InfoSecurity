1.2. Цель юнит-тестирования
Прежде чем углубляться в тему юнит-тестирования, давайте рассмотрим, для чего
вообще нужно юнит-тестирование и какой цели оно помогает добиться. Считается,
что юнит-тестирование улучшает качество кода проекта. И это правда: необходи-
мость написания юнит-тестов обычно приводит к улучшению качества кода. Но
это не главная цель юнит-тестирования, а всего лишь приятный побочный эффект.
Какова же тогда цель юнит-тестирования? Его цель — обеспечение стабильного роста
программного проекта. Ключевым словом здесь является «стабильный». В начале
жизни проекта развивать его довольно просто. Намного сложнее поддерживать это
развитие с прошествием времени.
На рис. 1.1 изображена динамика роста типичного проекта без тестов. Все на -
чинается быстро, потому что ничего вас не тормозит. Еще не приняты неудачные
архитектурные решения; еще нет существующего кода, который необходимо про-
рабатывать и поддерживать. Однако с течением времени вам приходится тратить
все больше времени, чтобы написать тот же по объему функционал, что и в начале
проекта. Со временем скорость разработки существенно замедляется — иногда даже
до состояния, в котором проект вообще перестает двигаться вперед. Проект без тестов быстро стартует, но и быстро замедляется до состояния,
в котором становится трудно двигаться вперед Такое снижение скорости разработки называется программная энтропия (software
entropy). Энтропия (мера беспорядка в системе) — математическая и научная кон-
цепция, также применимая к программным системам. (Если вас интересует мате-
матическая и научная сторона энтропии, обращайтесь к описанию второго закона
термодинамики.) В программировании энтропия проявляется в форме ухудшения качества кода. Каж-
дый раз, когда вы что-то изменяете в коде проекта, увеличивается степень беспорядка в нем — его энтропия. Если не принять должных мер (например, постоянной чистки
и рефакторинга), код постепенно усложняется и дезорганизуется. Исправление
одной ошибки приводит к появлению новых ошибок, а изменение в одной части
проекта нарушает работоспособность в нескольких других — возникает своего рода
«эффект домино». Со временем код становится ненадежным. И что еще хуже, его
становится все труднее вернуть в стабильное состояние.
Тесты помогают справиться с этой тенденцией. Они становятся своего рода «подушкой
безопасности» — средством, которое обеспечивает защиту против большинства ре-
грессий. Тесты помогают удостовериться в том, что существующая функциональность
работает даже после разработки новой функциональности или рефакторинга кода.
ОПРЕДЕЛЕНИЕ
Термин «регрессия» означает, что некоторая функциональность перестает работать по-
сле определенного события (обычно внесения изменений в код). Термины «регрессия»,
«программная ошибка» и «баг» — синонимы.
Недостаток юнит-тестирования заключается в том, что тесты требуют начальных
вложений, и иногда весьма значительных. Но в долгосрочной перспективе они
окупаются, позволяя проекту расти на более поздних стадиях. Разработка большин-
ства нетривиального программного обеспечения без помощи тестов практически
невозможна. Хотя юнит-тесты помогают развитию проекта, просто писать тесты недостаточно.
Плохо написанные тесты не меняют общей картины.
Как видно из рис. 1.2, плохие тесты на первых порах помогают замедлить ухудше-
ние качества кода: уменьшение скорости разработки идет медленнее по сравнению
с ситуацией, в которой тестов нет вообще. Однако это не меняет общей картины.
Возможно, такому проекту понадобится больше времени для того, чтобы войти
в фазу стагнации, но стагнация все равно неизбежна.
Не все тесты одинаково полезны. Некоторые из них вносят большой вклад в каче-
ство программного продукта. Другие только замедляют проект: дают много ложных
срабатываний, не помогают выявлять баги, работают медленно и создают сложности
с сопровождением. Многие компании пишут тесты без четкого понимания того,
способствуют ли они развитию проекта.
Невозможно добиться цели юнит-тестирования, просто добавив в проект больше
тестов. Необходимо учитывать как пользу этих тестов, так и затраты на их сопро-
вождение. Составляющая затрат на сопровождение определяется количеством
времени, ушедшего на:
 рефакторинг теста при рефакторинге нижележащего кода;
 выполнение теста при каждом изменении кода;
 отвлечение на ложные срабатывания теста;
 затраты на чтение теста при попытке понять, как работает нижележащий код.

 Легко создать тесты, общая польза которых близка к нулю или даже отрицательна
из-за высоких затрат на сопровождение. Чтобы сделать возможным стабильный
рост проекта, необходимо сосредоточиться исключительно на тестах с высоким
качеством — только такие тесты стоят того, чтобы включать их в ваш проект.

1.3. Использование метрик покрытия для оценки
качества тестов
В этом разделе речь пойдет о двух самых популярных метриках покрытия — code
coverage и branch coverage: о том, как их вычислять, как они используются и какие
проблемы с ними связаны. Я покажу, почему программистам не стоит ставить цель
достичь какого-то конкретного процента тестового покрытия и почему тестовое
покрытие само по себе не может служить критерием качества тестов.

ОПРЕДЕЛЕНИЕ
Метрика покрытия (coverage metric) показывает, какая доля исходного кода была вы-
полнена хотя бы одним тестом — от 0 до 100 %.
Существуют различные типы метрик покрытия, которые используются для оценки
качества тестов. Часто считается, что чем выше процент покрытия, тем лучше.
К сожалению, все не так просто. Хотя процент покрытия и предоставляет собой
ценную обратную связь, он не может использоваться для оценки качества тестов.
Ситуация здесь такая же, как с возможностью покрыть код проекта юнит-тестами:
процент покрытия служит хорошим негативным признаком, но плохим позитивным.
Если покрытие слишком мало — допустим, всего 10 % — это хороший признак того,
что тестов слишком мало. Однако обратное неверно: даже 100 %-ное покрытие еще
не гарантирует хорошего качества тестов. Тесты, обеспечивающие высокое покрытие,
тем не менее могут быть плохого качества.
Я уже упоминал, почему это так: нельзя просто добавить в проект случайные тесты
и надеяться на то, что они помогут вам поддерживать качество этого проекта. Но
давайте рассмотрим метрики тестового покрытия более подробно.
1.3.1. Метрика покрытия code coverage
Первая и наиболее часто используемая метрика покрытия — code coverage, также
известная как test coverage (рис. 1.3). Эта метрика равна отношению количества
строк кода, выполняемых по крайней мере одним тестом, к общему количеству
строк в основном коде проекта.

Пример поможет вам лучше понять, как вычисляется эта метрика. В листинге 1.1
показан метод IsStringLong и тест, который покрывает его код. Метод определяет,
является ли строка, переданная во входном параметре, длинной (в данном случае
«длинной» считается любая строка, длина которой превышает 5 символов). Тест
выполняет метод со строкой "abc" и проверяет, является ли эта строка длинной Листинг 1.1. Пример метода с частичным покрытием
public static bool IsStringLong(string input)
{
if (input.Length > 5)
return true;
return false;
}
public void Test()
{
bool result = IsStringLong("abc");
Assert.Equal(false, result);
}
Покрытие в этом примере вычисляется легко. Общее количество строк в методе
равно 5 (фигурные скобки тоже считаются). Количество строк, выполняемых в те-
сте, равно 4 — тест проходит все строки кода, кроме команды return true;. Таким
образом, покрытие равно 4/5 = 0,8 = 80 %.
Что будет, если отрефакторить этот метод и убрать избыточную команду if?
public static bool IsStringLong(string input)
{
return input.Length > 5;
}
public void Test()
{
bool result = IsStringLong("abc");
Assert.Equal(false, result);
}
Изменился ли процент покрытия? Да, изменился. Так как тест теперь выполняет
все три строки кода (команда return и две фигурные скобки), покрытие кода уве-
личилось до 100 %.
Но улучшилось ли качество тестов с таким рефакторингом? Конечно же, нет. Я про-
сто переставил код внутри метода. Тест по-прежнему проверяет то же количество
ветвлений в коде.
Этот простой пример показывает, как легко подтасовать процент покрытия. Чем ком-
пактнее ваш код, тем лучше становится этот процент, потому что в нем учитывается 
только количество строк. В то же время попытки втиснуть больше кода в меньший
объем не изменяют общую эффективность тестов.
1.3.2. Branch coverage
Другая метрика покрытия называется branch coverage (покрытием ветвей). Branch
coverage показывает более точные результаты, чем code coverage. Вместо того чтобы
использовать количество строк кода, эта метрика ориентируется на управляющие
структуры — такие как команды if и switch. Она показывает, какое количество
таких управляющих структур обходится по крайней мере одним тестом в проекте
(рис. 1.4).
Чтобы вычислить метрику branch coverage, необходимо подсчитать все возможные
ветви (branches) в коде и посмотреть, сколько из них выполняются тестами. Вер-
немся к предыдущему примеру:
public static bool IsStringLong(string input)
{
return input.Length > 5;
}
public void Test()
{
bool result = IsStringLong("abc");
Assert.Equal(false, result);
}
Метод IsStringLong содержит две ветви: одна для ситуации, в которой длина строко-
вого аргумента превышает пять символов, и другая для строк, длина которых менее
или равна 5 символам. Тест покрывает только одну из этих ветвей, поэтому метрика
покрытия составляет 1/2 = 0,5 = 50 %. При этом неважно, какое представление бу-
дет выбрано для тестируемого кода — будете ли вы использовать команду if, как
прежде, или выберете более короткую запись. Метрика branch coverage принимает
во внимание только количество ветвей; она не учитывает, сколько строк кода по-
надобилось для реализации этих ветвей.
Рис. 1.5 показывает, как можно визуализировать эту метрику. Все возможные вет-
ви в тестируемом коде представляются в виде графа, и вы проверяете, сколько из
них были пройдены тестами. В IsStringLong таких путей два, а тест отрабатывает
только один из них.

1.3.3. Проблемы с метриками покрытия
Хотя метрика branch coverage дает результаты лучше, чем метрика code coverage, вы
все равно не сможете положиться на эту метрику для определения качества тестов
по двум причинам:
 Невозможно гарантировать, что тест проверяет все компоненты результата ра-
боты тестируемой системы.
 Ни одна метрика покрытия не может учитывать ветвления кода во внешних
библиотеках.
Рассмотрим каждую из этих причин подробнее.
Невозможно гарантировать, что тест проверяет все компоненты
результата работы тестируемой системы
Чтобы код не просто отработал, а был протестирован, ваши юнит-тесты должны
содержать подходящие проверки. Иначе говоря, необходимо проверить результат
работы тестируемой системы. Более того, этот результат может состоять из несколь-
ких компонентов, и чтобы метрики покрытия имели смысл, необходимо проверить
все эти компоненты.
В листинге 1.2 приведена другая версия метода IsStringLong, которая записывает
последний результат в свойство WasLastStringLong.
Листинг 1.2. Версия IsStringLong с сохранением последнего результата
public static bool WasLastStringLong { get; private set; }
public static bool IsStringLong(string input)
{
bool result = input.Length > 5;
WasLastStringLong = result;
Первый результат
return result; Второй результат
}

public void Test()
{
bool result = IsStringLong("abc");
Assert.Equal(false, result);
Тест проверяет только второй результат
}
Теперь метод IsStringLong имеет два результата: явный, закодированный возвра-
щаемым значением, и неявный, которым является новое значение свойства. И хотя
второй, косвенный результат не проверяется, метрики покрытия демонстрируют
те же результаты: 100 % для code coverage, 50 % для branch coverage. Как видите,
метрики покрытия не гарантируют, что код реально тестируется — только то, что
он выполнялся в какой-то момент.
Крайним выражением этой ситуации с частично тестируемыми результатами яв-
ляется тестирование без проверок (assertion-free testing): когда вы пишете тесты,
которые вообще не содержат никаких проверочных команд. В листинге 1.3 приведен
пример тестирования без проверок.
Листинг 1.3. Тест без проверок всегда проходит
public void Test()
{
bool result1 = IsStringLong("abc");
Возвращает true
bool result2 = IsStringLong("abcdef"); Возвращает false
}
В этом тесте обе метрики — как code coverage, так и branch coverage — достигают 100 %.
В то же время этот тест совершенно бесполезен, поскольку он ничего не проверяет.
Но допустим, вы тщательно проверяете каждый результат тестируемого кода. Соз-
даст ли это (в сочетании с использованием branch coverage вместо code coverage)
надежный механизм, который может использоваться для определения качества
тестов? К сожалению, нет.
Ни одна метрика покрытия не может учитывать ветвления кода во внешних би-
блиотеках, что является второй проблемой в использовании этих метрик. Возьмем
следующий пример:
public static int Parse(string input)
{
return int.Parse(input);
}
public void Test()
{
int result = Parse("5");
Assert.Equal(5, result);
}
Метрика branch coverage показывает 100 %, и при этом тест проверяет все состав-
ляющие результата метода. Такая составляющая здесь всего одна — возвращаемое значение. В то же время такой тест совершенно не является исчерпывающим: он не
учитывает ветвления, через которые может проходить метод .NET Framework int.
Parse. В то же время даже такой простой метод может содержать большое количество
ветвлений, как видно из рис. 1.6.